const util = require('util');
const stream = require('stream');
const xtend     = require('xtend');

function Transform(config) {
    stream.Transform.call(this, config);
}
util.inherits(Transform, stream.Transform);
function getTransForm(transform, config) {
    if (!util.isFunction(transform)) {
        transform = function() {};
    }

    let transformInstance = new Transform(config);
    transformInstance._transform = transform;
    return transformInstance;
}
function getTransformObj(transform, config) {
    if (!util.isFunction(transform)) {
        transform = function() {};
    }

    return getTransForm(transform, xtend({ objectMode: true, highWaterMark: 16 }, config));
}

function addStream(streams, stream) {
    if (!stream.readable) {
        throw new Error('all input streams must be readable');
    }

    let self = this;
    stream._buffer = stream._buffer || [];
    stream.on('data', function(chunk) {
        if (stream == streams[0]) {
            self.push(chunk);
        } else {
            stream._buffer.push(chunk);
        }
    });
    stream.on('end', function() {
        let stream = streams[0];
        while (stream && stream._readableState.ended) {
            while (stream._buffer.length) {
                self.push(stream._buffer.shift());
            }
            streams.shift();
            stream = streams[0];
        }
    });
}
function Combine(streams) {
    stream.Readable.call(this, {
        objectMode: true
    });

    let __addStream = addStream.bind(this, streams);
    
    streams.forEach(__addStream);
}
util.inherits(Combine, stream.Readable);
function getCombine(streams, config) {
    if (!util.isArray(streams)) {
        throw new Error('streams must be arrat');
    }

    let readableStream = new Combine(streams);
    readableStream._read = function() {};
    return readableStream;
}

module.exports = {
    transform: getTransForm,
    transformObj: getTransformObj,
    combine: getCombine
};