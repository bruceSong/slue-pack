const fs = require('fs');
const fse = require('fs-extra');
const path = require('path');
const xtend = require('xtend');
const beautify = require('js-beautify');
const slueModule = require('slue-module');
const slueStream = require('slue-stream');
const slueFS = require('slue-fs');
const getConfig = require('./config');
const moduleReplacer = require('./lib/replacer');
const moduleWrap = require('./lib/wrap');

let libDir = path.resolve(__dirname, './lib');
let cacheDir = path.resolve(__dirname, './cache');
let modulesMap = {};

function groupByPlugins(relayData, config) {
    let group = {
        other: {
            moduleList: [],
            use: []
        }
    };

    if (config.plugins.length) {
        config.plugins.forEach(function(plugin, i) {
            relayData.moduleList.forEach(function(item, j) {
                let matchOne = false;

                let extname = path.extname(item.dir);
                plugin.exts.forEach(function(ext) {
                    if (extname === ext) {
                        group[`g${i}`] = group[`g${i}`] || {
                            moduleList: [],
                            use: plugin.use
                        };
                        group[`g${i}`].moduleList.push(item);
                        matchOne = true;
                    }
                });

                if (matchOne === false) {
                    group.other.moduleList.push(item);
                }
            });
        });
    } else {
        group.other.moduleList = relayData.moduleList;
    }

    return group;
}

function getFilesMap(config) {
    let filesMap = {
        groupMap: {},
        originMap: {}
    };

    for (let key in config.entry) {
        let slueModConfig = xtend({
            filePath: config.entry[key]
        }, config);

        let relayData = slueModule(slueModConfig);

        if (relayData) {
            modulesMap = Object.assign(modulesMap, relayData.modulesMap)
            filesMap.groupMap[key] = groupByPlugins(relayData, config);
            filesMap.originMap[key] = relayData;
        }
    }

    return filesMap;
}

function getStreams(groupMap) {
    let streams = [];
    for (let appKey in groupMap) {
        for (let groupKey in groupMap[appKey]) {
            let _con = groupMap[appKey][groupKey];
            let files = _con.moduleList.map(function(item) {
                return item.dir;
            });

            if (files.length) {
                let stream = slueFS.read(files, {
                    modulesMap: modulesMap,
                    entryName: appKey
                });

                _con.use.forEach(function(plugin) {
                    stream = stream.pipe(plugin);
                });

                streams.push(stream);
            }
        }
    }

    if (streams.length) {
        return streams;
    }
}

function cacheJSPack(jsPackMap) {
    //console.log(jsPackMap);
    let packsSrc = [];
    let packTpl = fs.readFileSync(`${libDir}/template.tpl`);
    for (var appkey in jsPackMap) {
        let packPath = `${cacheDir}/${appkey}.js`;
        packTpl = packTpl.toString();
        packTpl = packTpl.replace('{{slue-pack-modules-map}}', jsPackMap[appkey].join(',\n\r'));
        packTpl = beautify(packTpl, {
            indent_size: 4
        });
        fs.writeFileSync(packPath, packTpl);
        packsSrc.push(packPath);
    }
    return packsSrc;
}

module.exports = function(config) {
    config = getConfig(config);

    fse.emptyDirSync(cacheDir);

    let {
        groupMap,
        originMap
    } = getFilesMap(config);

    let streams = getStreams(groupMap);

    let handledFilesNum = 0;
    let thStream = slueStream.transformObj();
    let jsPackMap = {};
    let cssFileList = [];
    let fileList = [];
    slueStream.combine(streams)
        .pipe(moduleReplacer)
        .pipe(moduleWrap)
        .pipe(slueStream.transformObj(function(file, env, cb) {
            let extname = path.extname(file.path);

            if (extname === '.css' || extname === '.less' || extname === '.sass') {
                cssFileList.push(file.contents.toString());
            } else {
                jsPackMap[file.entryName] = jsPackMap[file.entryName] || [];
                jsPackMap[file.entryName].push(file.contents.toString());
            }

            handledFilesNum++;
            if (handledFilesNum >= Object.keys(modulesMap).length - Object.keys(config.externals).length) {
                let jsPackSrc = cacheJSPack(jsPackMap);

                if (cssFileList.length) {
                    let cssPackSrc = `${cacheDir}/app.css`;
                    fs.writeFileSync(cssPackSrc, cssFileList.join(''));
                    jsPackSrc.push(cssPackSrc);
                }

                slueFS.read(jsPackSrc).pipe(thStream);
            }

            cb(null, file);
        })).on('end', function() {
            console.log(123);
        });

    return thStream;
};